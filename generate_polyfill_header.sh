#!/bin/bash
# generate_polyfill_header.sh
# It will look for .js files in /$SCRIPT_FOLDER/ and its versioned subfolders,
# and generate /$HEADER_FILE.h with multiple NSString variables.

set -e

SCRIPT_FOLDER=$1
HEADER_FILE=$2
VARIABLE_NAME=$3
if [ -z "$SCRIPT_FOLDER" ] || [ -z "$HEADER_FILE" ] || [ -z "$VARIABLE_NAME" ]; then
  echo "Usage: $0 <script_folder> <header_file> <variable_name>"
  exit 1
fi

SCRIPT_ABS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPTS_SOURCE_DIR="$SCRIPT_ABS_DIR/$SCRIPT_FOLDER"
OUTPUT_H_FILE="$SCRIPT_ABS_DIR/$HEADER_FILE.h"

mkdir -p "$SCRIPTS_SOURCE_DIR"

# Function to process JS files and generate a C string variable
# Arguments: $1 = directory containing JS files, $2 = variable_name_in_header, $3 = output_h_file
# $4 = find_options (e.g., "-maxdepth 1" to search only current dir, empty for recursive)
# $5 = (optional) path prefix to save the final minified JS for inspection
process_js_bundle_to_header_var() {
  local js_search_dir="$1"
  local var_name="$2"
  local out_h_file="$3"
  local find_options="$4" # e.g., "-maxdepth 1" or ""
  local inspection_js_save_path_prefix="$5"

  local temp_js_concat
  local temp_js_minified
  local temp_js_transpiled

  temp_js_concat=$(mktemp)
  temp_js_minified=$(mktemp)
  temp_js_transpiled=$(mktemp)
  # Local trap for this function's temp files
  trap 'rm -f "$temp_js_concat" "$temp_js_minified" "$temp_js_transpiled"; trap - RETURN EXIT INT TERM' RETURN EXIT INT TERM

  # Find JS files, sort them, and concatenate after removing full-line comments
  find "$js_search_dir" $find_options -name "*.js" -type f -print0 | sort -z | while IFS= read -r -d $'\0' js_file; do
    if [ -f "$js_file" ] && [ -s "$js_file" ]; then # Check if it's a file and non-empty before grepping
        grep -v '^[[:space:]]*//' "$js_file" >> "$temp_js_concat"
    fi
  done

  echo -n "static NSString *$var_name = @\"" >> "$out_h_file"

  if [ -s "$temp_js_concat" ]; then
    # Check for npx command
    if ! command -v npx &> /dev/null; then
        echo "Error: npx command not found. Please install Node.js and npm." >&2
        # Append empty string and continue, or exit based on desired strictness
        echo "\"; // npx not found, JavaScript content omitted" >> "$out_h_file"; echo "" >> "$out_h_file"; return 1
    fi

    # Transpile with Babel
    if ! npx babel "$temp_js_concat" -o "$temp_js_transpiled" 2>/dev/null; then # Suppress babel stderr for cleaner output, check exit code
      echo "Warning: Babel transpilation failed for $var_name (source: $js_search_dir). Output might be non-ES5." >&2
      # Decide if we should use non-transpiled or fail. For now, copy concat to transpiled.
      cp "$temp_js_concat" "$temp_js_transpiled"
    fi

    # Minify with UglifyJS
    if ! npx uglifyjs "$temp_js_transpiled" -o "$temp_js_minified" 2>/dev/null; then # Suppress uglifyjs stderr
      echo "Warning: UglifyJS minification failed for $var_name (source: $js_search_dir). Output might be unminified." >&2
      # Use transpiled (or original if babel failed) if uglify fails
      cp "$temp_js_transpiled" "$temp_js_minified"
    fi

    # Save a copy of the minified JS for inspection if a prefix is provided
    if [ -n "$inspection_js_save_path_prefix" ]; then
      local inspection_file_name="${inspection_js_save_path_prefix}.${var_name}.js"
      cp "$temp_js_minified" "$inspection_file_name"
      # Optionally, add a comment in the .h file about the saved .js file
      # echo "// Minified JS for $var_name also saved to $(basename "$inspection_file_name")" >> "$out_h_file"
    fi

    echo "\\" >> "$out_h_file" # Start of multiline string content
    # Escape backslashes and double quotes, and add a backslash at the end of each line
    sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/$/\\/' "$temp_js_minified" >> "$out_h_file"
    # Remove the trailing backslash and newline from the last line
    truncate -s-1 "$out_h_file"
    echo "\";" >> "$out_h_file"
  else
    # No JS content found or processed
    echo "\"; // No JS content found for $var_name in $js_search_dir" >> "$out_h_file"
  fi
  echo "" >> "$out_h_file" # Add a blank line for readability before the next variable or end of file

  # Trap will handle cleanup of temp_js_concat, temp_js_minified, temp_js_transpiled
  return 0
}

# --- Main Script Execution ---

# Initial header content (overwrite existing file)
{
  echo "// This file is auto-generated by $(basename "$0"). DO NOT EDIT."
  echo "#import <Foundation/Foundation.h>"
  echo ""
} > "$OUTPUT_H_FILE"

INSPECTION_JS_SAVE_PATH_PREFIX="$SCRIPT_ABS_DIR/$HEADER_FILE" # Base name for .h.js files

# Process JS files directly in SCRIPTS_SOURCE_DIR (base polyfill, non-recursive)
echo "// Base polyfill scripts (for all versions or as fallback)" >> "$OUTPUT_H_FILE"
process_js_bundle_to_header_var "$SCRIPTS_SOURCE_DIR" "$VARIABLE_NAME" "$OUTPUT_H_FILE" "-maxdepth 1" "$INSPECTION_JS_SAVE_PATH_PREFIX"

# Process version-specific JS files from subdirectories
find "$SCRIPTS_SOURCE_DIR" -mindepth 1 -maxdepth 1 -type d | while IFS= read -r version_dir_path; do
  version_folder_name=$(basename "$version_dir_path")

  # Regex to check if folder name looks like a version (e.g., 16.4, 15, 17.0.1)
  # Allows digits, dots, and underscores as separators.
  if [[ "$version_folder_name" =~ ^[0-9]+([._][0-9]+)*$ ]]; then
    echo "// Polyfill scripts for iOS < $version_folder_name" >> "$OUTPUT_H_FILE"

    # Sanitize version folder name for use in a C variable name (replace non-alphanumeric with underscore)
    sanitized_version_name=$(echo "$version_folder_name" | sed 's/[^a-zA-Z0-9_]/_/g')

    specific_var_name="${VARIABLE_NAME}_before_${sanitized_version_name}"

    # Process all JS files within this version_dir_path (recursively, so find_options is empty)
    process_js_bundle_to_header_var "$version_dir_path" "$specific_var_name" "$OUTPUT_H_FILE" "" "$INSPECTION_JS_SAVE_PATH_PREFIX"
  else
    echo "// Subdirectory '$version_folder_name' in $SCRIPTS_SOURCE_DIR does not match version pattern (e.g., 16.4), skipping for specific polyfill generation." >> "$OUTPUT_H_FILE"
    echo "// JS files in '$version_folder_name/' will not be included unless moved or the directory is renamed to a version format." >> "$OUTPUT_H_FILE"
    echo "" >> "$OUTPUT_H_FILE"
  fi
done

echo "Generated $OUTPUT_H_FILE successfully."
